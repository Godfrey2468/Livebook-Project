# Livebook Tutorial

## Scalability

An application program would be scalable if it could be moved from a smaller to a larger operating system and take full advantage of the larger operating system in terms of performance (user response time and so forth) and the larger number of users that could be handled.

All Elixir code runs inside lightweight threads of execution (called processes) that are isolated and exchange information via messages
Due to their lightweight nature, you can run hundreds of thousands of processes concurrently in the same machine, using all machine resources efficiently (vertical scaling). Processes may also communicate with other processes running on different machines to coordinate work across multiple nodes (horizontal scaling).

```elixir
current_process = self()

# Spawn an Elixir process (not an operating system one!)
spawn_link(fn ->
  send(current_process, {:msg, "hello world"})
end)

# Block until the message is received
receive do
  {:msg, contents} -> IO.puts(contents)
end
```

For further below is a code that spawns up one million processes and gives the process Identifyers (PID) and is done so in about 20 seconds.

```elixir
for _ <- 1..1_000_000 do
  spawn(fn -> :ok end)
end
```

## Concurrency

Test Github Version Control

<!-- livebook:{"break_markdown":true} -->

We meet our first intergration using Livebook called Kino, this can be used to trace processes as shown below.

```elixir
Kino.Process.render_seq_trace(fn ->
  1..4
  |> Task.async_stream(
    fn _ -> Process.sleep(Enum.random(100..300)) end,
    max_concurrency: 4
  )
  |> Stream.run()
end)
```

## Fault Tolerance

Elixir uses supervisor to monitor the child processes. If a child process crashes, supervisor will restart it.
A supervisor is a process which supervises other processes, which we refer to as child processes. Supervisors are used to build a hierarchical process structure called a supervision tree. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.

Livebook does allow spawning of Supervisor and child processes and thus handling Fault Tolerance.

```elixir
Mix.install([
  {:kino, "~> 0.9.1"}
])
```

```elixir
Kino.Process.render_seq_trace(fn ->
  child =
    spawn(fn ->
      receive do
        {:ping, caller} -> send(caller, :pong)
      end
    end)

  send(child, {:ping, self()})

  receive do
    :pong -> :it_worked!
  end
end)
```

## Functional Programming

Functional programming is a paradigm of building computer programs using expressions and functions without mutating state and data. Meaning in Elixir data is immutable.

## Erlang Compatability

When we go to the link;

https://github.com/livebook-dev/livebook/blob/main/lib/livebook/notebook/learn/intro_to_livebook.livemd

Under erlang support,

Livebook also allows developers to write Erlang code. To do so, click on the submenu option on the right side of the "Elixir" cell button and choose Erlang.

```elixir
[io:format("~ts", [Cat]) || Cat <- Cats].
```

## OTP DISTRIBUTION
